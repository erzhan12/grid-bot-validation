# 0008 — Data Recorder (Standalone Mainnet Capture)

## Context

Phases B–H are complete. The project can run a live grid bot (`gridbot`), backtest historical data (`backtest`), and compare results (`comparator`). The missing piece is **real mainnet data** to validate against. The existing `event_saver` is tightly coupled to `gridbot` (shared orchestrator, account lifecycle, run_id dependency). We need a standalone recorder that captures raw Bybit mainnet WebSocket data to SQLite for multi-day unattended runs, independent of any trading activity.

The recorder reuses `bybit_adapter` (WebSocket clients, normalizer) and `grid_db` (models, writers pattern, repositories) but has its own entry point, config, and lifecycle. It is a **new app** at `apps/recorder/`.

---

## What It Does

1. Connects to Bybit **mainnet** public WebSocket streams (ticker, publicTrade) for configured symbols
2. Optionally connects to authenticated private streams (execution, order, position, wallet) if API credentials are provided
3. Persists all data to a local SQLite database using the existing `grid_db` schema
4. Detects WebSocket disconnections and reconciles gaps via REST API
5. Logs connection health (uptime, gap count, message rates) for monitoring multi-day runs
6. Runs indefinitely until SIGINT/SIGTERM

---

## Architecture

```
apps/recorder/
├── conf/
│   └── recorder.yaml.example
├── src/recorder/
│   ├── __init__.py
│   ├── main.py           # CLI entry point + signal handling
│   ├── config.py          # YAML config model (Pydantic)
│   └── recorder.py        # Core orchestrator
├── tests/
│   ├── conftest.py
│   ├── test_config.py
│   ├── test_recorder.py
│   └── test_health.py
└── pyproject.toml
```

---

## Files to Create

### 1. `apps/recorder/pyproject.toml`

Workspace package following the `event_saver` pattern. Dependencies:
- `bybit-adapter` (workspace) — WS clients, REST client, normalizer
- `grid-db` (workspace) — DatabaseFactory, models, repositories
- `pyyaml>=6.0` — YAML config loading
- `pydantic>=2.0` — config validation

### 2. `apps/recorder/src/recorder/config.py`

YAML-based config model following the `gridbot/config.py` pattern (not env vars like event_saver).

**`RecorderConfig`** (Pydantic BaseModel):
- `symbols: list[str]` — symbols to record (e.g., `["BTCUSDT"]`)
- `database_url: str` — SQLite path (default: `sqlite:///recorder.db`)
- `testnet: bool` — mainnet vs testnet (default: `false` — **unlike gridbot which defaults to testnet**)
- `batch_size: int` — writer batch size (default: 100)
- `flush_interval: float` — writer flush interval in seconds (default: 5.0)
- `gap_threshold_seconds: float` — min gap to trigger REST reconciliation (default: 5.0)
- `health_log_interval: float` — seconds between health log lines (default: 300.0)
- `account: Optional[AccountConfig]` — optional single account for private stream capture

**`AccountConfig`** (Pydantic BaseModel):
- `api_key: str`
- `api_secret: str`

**`load_config(path)`** function — loads YAML, searches `RECORDER_CONFIG_PATH` env var → `conf/recorder.yaml` → `recorder.yaml`.

### 3. `apps/recorder/src/recorder/recorder.py`

Core orchestrator. Simpler than `EventSaver` — no multi-account lifecycle, single optional account configured at startup.

**`Recorder`** class:
- Constructor: `config: RecorderConfig`, `db: DatabaseFactory`
- `async start()`:
  1. Store event loop reference
  2. Initialize writers: `TradeWriter`, `TickerWriter` (always), plus `ExecutionWriter`, `OrderWriter`, `PositionWriter`, `WalletWriter` if account configured
  3. Start auto-flush on all writers
  4. Initialize `GapReconciler` with REST client
  5. Create `PublicCollector` for configured symbols, wire callbacks
  6. If account configured: seed DB parent records (User, BybitAccount, Strategy with fixed UUIDs) and create a new `Run` row per session so that `execution_writer` and `order_writer` can persist data (they require a valid `run_id` FK)
  7. If account configured: create `PrivateCollector` with `AccountContext` using the session `run_id`
  8. Start collectors
  9. Start health logging task
- `async stop()`:
  1. Stop health logging
  2. Stop collectors
  3. Stop all writers (flushes remaining buffers)
  4. Mark Run as `completed` with `end_ts`
  5. Log final stats
- `async run_until_shutdown()`: signal handler loop (SIGINT/SIGTERM)
- `_handle_ticker(event)` — route to TickerWriter via `run_coroutine_threadsafe`
- `_handle_trades(events)` — route to TradeWriter via `run_coroutine_threadsafe`
- `_handle_execution(event)` — route to ExecutionWriter via `run_coroutine_threadsafe`
- `_handle_order(account_id, event)` — route to OrderWriter
- `_handle_position(account_id, msg)` — route to PositionWriter
- `_handle_wallet(account_id, msg)` — route to WalletWriter
- `_handle_public_gap(symbol, start, end)` — trigger `reconciler.reconcile_public_trades()`
- `_handle_private_gap(start, end)` — trigger `reconciler.reconcile_executions()` per symbol (requires account + run_id)
- `_seed_db_records() -> UUID` — upserts User/BybitAccount/Strategy with fixed UUIDs, creates a new Run row; returns `run_id`
- `_mark_run_status(status)` — sets Run status (e.g. `completed`, `error`) with `end_ts`
- `async _health_log_loop()` — periodic task that logs:
  - Uptime (seconds since start)
  - Per-writer stats (total_written, buffer_size, msgs_per_sec)
  - Public WS connection state (connected/disconnected, reconnect count)
  - Total gaps detected and reconciled

**Key difference from EventSaver**: No multi-account support, no `add_account()`/`remove_account()` lifecycle. Single optional account, configured at startup.

### 4. `apps/recorder/src/recorder/main.py`

CLI entry point following `gridbot/main.py` pattern.

- `parse_args()` — `--config PATH`, `--debug` flag
- `async main(config_path, debug)`:
  1. Configure logging (DEBUG if `--debug`, else INFO)
  2. Load config via `load_config()`
  3. Log config summary (symbols, testnet, database_url)
  4. Initialize `DatabaseFactory`, call `create_tables()`
  5. Create `Recorder`, call `start()`, then `run_until_shutdown()`
- `cli()` — argparse wrapper, calls `asyncio.run(main(...))`
- `if __name__ == "__main__": cli()`

### 5. `apps/recorder/conf/recorder.yaml.example`

Example config file. Key fields:
```yaml
symbols:
  - "BTCUSDT"

database_url: "sqlite:///recorder.db"
testnet: false  # mainnet by default

batch_size: 100
flush_interval: 5.0
gap_threshold_seconds: 5.0
health_log_interval: 300  # log health every 5 minutes

# Optional: uncomment to also capture private streams
# account:
#   api_key: "YOUR_API_KEY"
#   api_secret: "YOUR_API_SECRET"
```

---

## Files to Modify

### 6. `Makefile`

Add recorder test target to the `test` chain:
```
uv run pytest apps/recorder/tests --cov=recorder --cov-append -q
```

### 7. Root `pyproject.toml`

Add `apps/recorder` to the workspace members list.

---

## Reuse from Existing Code

The recorder reuses these components **directly** (imported, not copied):

| Component | Package | Usage |
|-----------|---------|-------|
| `PublicCollector` | `event_saver` | Public WS stream collection + gap detection |
| `PrivateCollector`, `AccountContext` | `event_saver` | Private WS stream collection (optional) |
| `TradeWriter`, `TickerWriter`, `ExecutionWriter`, `OrderWriter`, `PositionWriter`, `WalletWriter` | `event_saver` | Buffered bulk DB writes |
| `GapReconciler` | `event_saver` | REST-based gap filling |
| `PublicWebSocketClient`, `PrivateWebSocketClient` | `bybit_adapter` | (used indirectly via collectors) |
| `BybitRestClient` | `bybit_adapter` | (used indirectly via reconciler) |
| `BybitNormalizer` | `bybit_adapter` | (used indirectly via collectors) |
| `DatabaseFactory`, `DatabaseSettings` | `grid_db` | DB session management |
| All ORM models and repositories | `grid_db` | Data persistence |

This means `recorder` depends on `event-saver` as a workspace dependency (same as how `gridbot` depends on it). The recorder is essentially a thin orchestration wrapper around existing collectors + writers.

---

## What the Recorder Does NOT Do

- No trading (no `GridEngine`, no `IntentExecutor`)
- No multi-tenant lifecycle management — it seeds minimal parent rows (User, BybitAccount, Strategy) with fixed UUIDs and creates one Run per session, but does not manage account add/remove at runtime
- No Telegram notifications
- No position risk management
- No backtest or comparison — that's the next step (replay engine)

---

## Tests

### `test_config.py`
- Valid YAML parses correctly
- Missing file raises `FileNotFoundError`
- Invalid YAML raises validation error
- Default values (testnet=false, batch_size=100, etc.)
- Optional account config: present vs absent

### `test_recorder.py`
- `start()` initializes writers and collectors (mock WS clients)
- `stop()` stops all components, flushes writers
- Ticker callback routes to TickerWriter
- Trade callback routes to TradeWriter
- Gap callback triggers reconciler
- Health log task runs at configured interval
- Without account config: no private collector created
- With account config: private collector created and started

### `test_health.py`
- Health log output contains uptime, writer stats, connection state
- Health log handles disconnected state gracefully
