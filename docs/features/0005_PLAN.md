# Phase F: Backtest Rewrite

## Overview

Create a backtest system that reuses gridcore's `GridEngine` with a trade-through fill model for simulating grid trading strategies using historical price data.

## Architecture

**New package**: `apps/backtest/` (separate from gridbot)

**Dependencies**: `gridcore`, `grid-db` (NO `bybit_adapter`)

## Package Structure

```
apps/backtest/
├── pyproject.toml
├── conf/
│   └── backtest.yaml.example
├── src/backtest/
│   ├── __init__.py
│   ├── config.py             # BacktestConfig, BacktestStrategyConfig
│   ├── data_provider.py      # HistoricalDataProvider
│   ├── fill_simulator.py     # TradeThroughFillSimulator
│   ├── position_tracker.py   # BacktestPositionTracker
│   ├── order_manager.py      # BacktestOrderManager
│   ├── executor.py           # BacktestExecutor
│   ├── runner.py             # BacktestRunner
│   ├── engine.py             # BacktestEngine
│   ├── session.py            # BacktestSession
│   ├── reporter.py           # BacktestReporter
│   └── main.py               # CLI entry point
└── tests/
```

## Key Components

### 1. HistoricalDataProvider (data_provider.py)

Provides historical price data as `TickerEvent` stream.

```python
class HistoricalDataProvider:
    def __init__(self, db: DatabaseFactory, symbol: str, start_ts: datetime, end_ts: datetime)
    def __iter__(self) -> Iterator[TickerEvent]
    def get_data_range_info(self) -> dict
```

**Data source**: `PublicTrade` table or new `TickerSnapshot` table.

### 2. TradeThroughFillSimulator (fill_simulator.py)

Core fill logic implementing trade-through model.

```python
class TradeThroughFillSimulator:
    def check_fill(self, order: SimulatedOrder, current_price: Decimal) -> bool:
        """
        BUY fills when current_price <= limit_price
        SELL fills when current_price >= limit_price
        """

    def get_fill_price(self, order: SimulatedOrder) -> Decimal:
        """Always returns limit price (conservative)"""
```

**Reference**: `bbu_reference/backtest_reference/bbu_backtest-main/src/backtest_order_manager.py:209-225`

### 3. BacktestOrderManager (order_manager.py)

Manages simulated order book.

```python
@dataclass
class SimulatedOrder:
    order_id: str
    client_order_id: str
    symbol: str
    side: str              # 'Buy' or 'Sell'
    price: Decimal
    qty: Decimal
    direction: str         # 'long' or 'short'
    status: str            # 'pending', 'filled', 'cancelled'
    created_ts: datetime
    filled_ts: Optional[datetime] = None

class BacktestOrderManager:
    def __init__(self, fill_simulator: TradeThroughFillSimulator, commission_rate: Decimal)
    def place_order(self, intent: PlaceLimitIntent, timestamp: datetime) -> SimulatedOrder
    def cancel_order(self, order_id: str, timestamp: datetime) -> bool
    def check_fills(self, current_price: Decimal, timestamp: datetime) -> list[ExecutionEvent]
    def get_limit_orders(self) -> dict[str, list[dict]]
```

### 4. BacktestPositionTracker (position_tracker.py)

Tracks positions and calculates PnL.

```python
@dataclass
class PositionState:
    size: Decimal = Decimal('0')
    avg_entry_price: Decimal = Decimal('0')
    realized_pnl: Decimal = Decimal('0')
    unrealized_pnl: Decimal = Decimal('0')
    commission_paid: Decimal = Decimal('0')
    funding_paid: Decimal = Decimal('0')

class BacktestPositionTracker:
    def __init__(self, direction: str, commission_rate: Decimal)
    def process_fill(self, side: str, qty: Decimal, price: Decimal) -> Decimal  # Returns realized PnL
    def calculate_unrealized_pnl(self, current_price: Decimal) -> Decimal
    def apply_funding(self, rate: Decimal, current_price: Decimal) -> Decimal
```

**Note**: Separate from `gridcore.Position` which handles risk multipliers, not PnL.

### 5. BacktestExecutor (executor.py)

Executes intents against simulated order book.

```python
class BacktestExecutor:
    def __init__(self, order_manager: BacktestOrderManager, qty_calculator: Callable)
    def execute_place(self, intent: PlaceLimitIntent, timestamp: datetime) -> OrderResult
    def execute_cancel(self, intent: CancelIntent, timestamp: datetime) -> CancelResult
```

### 6. BacktestRunner (runner.py)

Wraps GridEngine for backtest (pattern from `gridbot.runner.StrategyRunner`).

```python
class BacktestRunner:
    def __init__(self, strategy_config, executor, position_tracker_long, position_tracker_short)

    def process_tick(self, event: TickerEvent) -> None:
        # 1. Check fills from previous tick
        fills = self._executor.order_manager.check_fills(event.last_price, event.exchange_ts)

        # 2. Process fills (update positions, create ExecutionEvents)
        for fill in fills:
            self._process_fill(fill)
            self._engine.on_event(fill)

        # 3. Get new intents from engine
        limit_orders = self._executor.order_manager.get_limit_orders()
        intents = self._engine.on_event(event, limit_orders)

        # 4. Execute intents
        for intent in intents:
            if isinstance(intent, PlaceLimitIntent):
                self._executor.execute_place(intent, event.exchange_ts)
            elif isinstance(intent, CancelIntent):
                self._executor.execute_cancel(intent, event.exchange_ts)
```

### 7. BacktestEngine (engine.py)

Main orchestrator.

```python
class BacktestEngine:
    def __init__(self, config: BacktestConfig, db: DatabaseFactory)

    def run(self, symbol: str, start_ts: datetime, end_ts: datetime) -> BacktestSession:
        # Create session
        # Create data provider
        # Create runner for each strategy
        # Main loop: iterate ticks, process, check funding
        # Finalize and persist results
```

### 8. BacktestSession (session.py)

In-memory results storage.

```python
@dataclass
class BacktestTrade:
    trade_id: str
    symbol: str
    side: str
    price: Decimal
    qty: Decimal
    direction: str
    timestamp: datetime
    order_id: str
    realized_pnl: Decimal
    commission: Decimal

@dataclass
class BacktestMetrics:
    total_trades: int
    winning_trades: int
    win_rate: float
    total_pnl: Decimal
    max_drawdown: Decimal
    sharpe_ratio: float
    profit_factor: float

class BacktestSession:
    def __init__(self, session_id: str, initial_balance: Decimal)
    def record_trade(self, trade: BacktestTrade) -> None
    def update_equity(self, timestamp: datetime, equity: Decimal) -> None
    def finalize(self) -> BacktestMetrics
```

### 9. BacktestConfig (config.py)

```python
class BacktestStrategyConfig(BaseModel):
    strat_id: str
    symbol: str
    tick_size: Decimal
    grid_count: int = 50
    grid_step: float = 0.2
    amount: str = "x0.001"
    max_margin: float = 8.0
    commission_rate: Decimal = Decimal('0.0002')

class BacktestConfig(BaseModel):
    strategies: list[BacktestStrategyConfig]
    database_url: str = "sqlite:///gridbot.db"
    initial_balance: Decimal = Decimal('10000')
    enable_funding: bool = True
    funding_rate: Decimal = Decimal('0.0001')
    wind_down_mode: str = "leave_open"  # or "close_all"
```

## Trade-Through Fill Algorithm

```
For each tick (TickerEvent):

1. CHECK_FILLS:
   For each active_order:
     If order.side == 'Buy' AND tick.last_price <= order.price → FILL
     If order.side == 'Sell' AND tick.last_price >= order.price → FILL

2. UPDATE_POSITIONS:
   For each fill:
     If opens position → position.add(qty, price)
     If closes position → realized_pnl = position.reduce(qty, price)
     Deduct commission

3. UPDATE_GRID:
   For each fill:
     engine.on_event(ExecutionEvent)

4. GET_NEW_INTENTS:
   limit_orders = order_manager.get_limit_orders()
   intents = engine.on_event(tick, limit_orders)

5. EXECUTE_INTENTS:
   For each intent:
     PlaceLimitIntent → order_manager.place_order()
     CancelIntent → order_manager.cancel_order()

6. UPDATE_EQUITY:
   unrealized = long.unrealized_pnl(price) + short.unrealized_pnl(price)
   equity = balance + realized_pnl + unrealized
   session.update_equity(timestamp, equity)
```

## Funding Simulation

Match Bybit's 8-hour schedule (00:00, 08:00, 16:00 UTC):

```python
class FundingSimulator:
    FUNDING_HOURS = [0, 8, 16]

    def check_funding(self, current_time, position_tracker, current_price) -> Decimal:
        if is_funding_time(current_time):
            position_value = position_tracker.size * current_price
            payment = position_value * rate
            # Long pays when rate > 0, short receives
            return -payment if direction == 'long' else payment
        return Decimal('0')
```

## Database Integration

### Existing Models Used
- `Run` model with `run_type='backtest'`
- `PublicTrade` table for historical data

### New Model
```python
class BacktestExecution(Base):
    __tablename__ = "backtest_executions"

    id: Mapped[int] = mapped_column(BigInteger(), primary_key=True)
    run_id: Mapped[str] = mapped_column(ForeignKey("runs.run_id"))
    symbol: Mapped[str]
    side: Mapped[str]
    price: Mapped[Decimal]
    qty: Mapped[Decimal]
    direction: Mapped[str]
    exchange_ts: Mapped[datetime]
    realized_pnl: Mapped[Decimal]
    commission: Mapped[Decimal]
```

## Data Flow Diagram

```
HistoricalDataProvider (PublicTrade table)
         ↓
    TickerEvent
         ↓
BacktestEngine → BacktestRunner → GridEngine.on_event()
                                        ↓
                              PlaceLimitIntent / CancelIntent
                                        ↓
                              BacktestExecutor
                                        ↓
                              BacktestOrderManager
                                        ↓
                              ExecutionEvent (on fill)
                                        ↓
                              BacktestPositionTracker
                                        ↓
                              BacktestSession
                                        ↓
                              Database (Run, BacktestExecution)
```

## Configuration Example (backtest.yaml)

```yaml
strategies:
  - strat_id: "btcusdt_backtest"
    symbol: "BTCUSDT"
    tick_size: "0.1"
    grid_count: 50
    grid_step: 0.2
    amount: "x0.001"
    max_margin: 8.0

database_url: "sqlite:///gridbot.db"
initial_balance: 10000
enable_funding: true
funding_rate: 0.0001
wind_down_mode: "leave_open"
```

## CLI Usage

```bash
# Run backtest with config file
uv run python -m backtest.main --config conf/backtest.yaml

# Run with specific date range
uv run python -m backtest.main --config conf/backtest.yaml \
    --start "2025-01-01" --end "2025-01-31"

# Export results to CSV
uv run python -m backtest.main --config conf/backtest.yaml --export results.csv
```

## Metrics Calculated

| Category | Metrics |
|----------|---------|
| Trading | Total trades, winning trades, win rate, avg win/loss |
| PnL | Realized PnL, unrealized PnL, commission, funding, net PnL |
| Risk | Max drawdown, drawdown duration, Sharpe ratio |
| Position | Max position size, avg holding time, turnover |

## Critical Files to Reference

| File | Purpose |
|------|---------|
| `packages/gridcore/src/gridcore/engine.py` | GridEngine to reuse directly |
| `apps/gridbot/src/gridbot/runner.py` | Pattern for BacktestRunner |
| `bbu_reference/backtest_reference/.../backtest_order_manager.py` | Reference fill logic |
| `shared/db/src/grid_db/models.py` | Run model, new BacktestExecution |
| `shared/db/src/grid_db/repositories.py` | PublicTradeRepository |

## Verification

1. **Unit tests**: Each module tested in isolation
2. **Integration test**: Full backtest with sample PublicTrade data
3. **Comparison test**: Same events produce same intents as live engine
4. **Run tests**: `uv run pytest apps/backtest/tests -v`
