# Phase E: Live Bot Rewrite

## Overview

Rewrite the live trading bot as a multi-tenant orchestrator that uses `gridcore` for strategy logic, `bybit_adapter` for exchange communication, and `event_saver` writers for persistence. The bot runs in a single process handling all accounts, with hybrid async event loop and in-memory order tracking.

**Location**: `apps/gridbot/`

## Architecture Decisions

| Decision | Choice |
|----------|--------|
| Process model | Single process, all accounts |
| Config source | Single YAML file |
| Event loop | Hybrid: async WebSocket + periodic polling (~63s for positions) |
| Order state | In-memory, reconcile from exchange on startup/reconnect |
| Failed intents | Queue for retry (3 attempts, 30s max) |
| Shadow mode | Log intents only, no execution |
| Startup sync | Adopt existing orders from exchange |
| DB persistence | Everything (orders, executions, positions, wallet, tickers) |
| Logging | JSON to file, human-readable to console |

## Components

### 1. Config Module (`config.py`)

**Purpose**: Load and validate YAML configuration.

**Structure**:
```yaml
# conf/gridbot.yaml
accounts:
  - name: "main_account"
    api_key: "xxx"
    api_secret: "yyy"
    testnet: true

strategies:
  - strat_id: "btcusdt_main"
    account: "main_account"
    symbol: "BTCUSDT"
    tick_size: "0.1"
    grid_count: 50
    grid_step: 0.2
    amount: "x0.001"  # wallet fraction
    max_margin: 8
    shadow_mode: false
```

**Implementation**:
- Pydantic models: `AccountConfig`, `StrategyConfig`, `GridbotConfig`
- Load from `conf/gridbot.yaml` or `GRIDBOT_CONFIG_PATH` env var
- Validate account references in strategies

### 2. Intent Executor (`executor.py`)

**Purpose**: Convert intents to Bybit API calls.

**Key Functions**:
- `execute_place(intent: PlaceLimitIntent) -> OrderResult`
- `execute_cancel(intent: CancelIntent) -> bool`
- `execute_batch(intents: list) -> list[Result]`

**Dependencies**:
- Extend `BybitRestClient` with order methods:
  - `place_order(symbol, side, price, qty, reduce_only, client_order_id) -> dict`
  - `cancel_order(symbol, order_id) -> bool`
  - `get_open_orders(symbol) -> list[dict]`

**File to modify**: `packages/bybit_adapter/src/bybit_adapter/rest_client.py`

Add methods (reference `bbu_reference/bbu2-master/bybit_api_usdt.py:246-269, 442-448`):
```python
def place_order(self, symbol, side, order_type, qty, price,
                reduce_only=False, order_link_id=None) -> dict
def cancel_order(self, symbol, order_id) -> bool
def get_open_orders(self, symbol, limit=50) -> list[dict]
```

### 3. Retry Queue (`retry_queue.py`)

**Purpose**: Queue and retry failed intents.

**Algorithm**:
1. On intent execution failure, add to queue with `(intent, attempt_count, next_retry_ts)`
2. Background task checks queue every 1s
3. For each due item:
   - If `attempt_count < 3` and `elapsed < 30s`: retry execution
   - On success: remove from queue
   - On failure: increment `attempt_count`, set `next_retry_ts` with exponential backoff (1s, 2s, 4s)
   - If max attempts reached: log error, remove from queue

**Data Structure**:
```python
@dataclass
class RetryItem:
    intent: PlaceLimitIntent | CancelIntent
    attempt_count: int
    first_attempt_ts: datetime
    next_retry_ts: datetime
    last_error: str
```

### 4. Strategy Runner (`runner.py`)

**Purpose**: Wrap `GridEngine` with execution context.

**Class**: `StrategyRunner`

**Responsibilities**:
- Owns one `GridEngine` instance
- Owns linked `Position` pair (long/short)
- Routes events to engine
- Executes returned intents (or logs in shadow mode)
- Tracks placed orders in-memory: `dict[client_order_id, OrderState]`

**Key Methods**:
```python
async def on_ticker(self, event: TickerEvent) -> None
async def on_execution(self, event: ExecutionEvent) -> None
async def on_order_update(self, event: OrderUpdateEvent) -> None
async def on_position_update(self, positions: list[dict]) -> None
async def check_positions(self) -> None  # Periodic, ~63s
```

**Order State Tracking**:
```python
@dataclass
class TrackedOrder:
    client_order_id: str
    order_id: str | None  # None until confirmed by exchange
    intent: PlaceLimitIntent
    status: str  # 'pending', 'placed', 'filled', 'cancelled', 'failed'
    placed_ts: datetime
```

**Shadow Mode**:
- If `shadow_mode=True`: log intents, do not execute
- Track hypothetical state for comparison

### 5. Reconciler (`reconciler.py`)

**Purpose**: Sync engine state with exchange on startup/reconnect.

**Startup Algorithm**:
1. Fetch open orders from exchange: `rest_client.get_open_orders(symbol)`
2. Build `limit_orders` dict in format expected by `GridEngine.on_event()`
3. For each open order, check if `client_order_id` matches our pattern
4. Inject into runner's tracked orders
5. First `on_event()` call will use these orders to avoid duplicates

**Reconnect Algorithm**:
1. Detect WebSocket reconnection event
2. Fetch current open orders
3. Compare with in-memory tracked orders
4. Log discrepancies (orphan orders, missing orders)
5. Update in-memory state to match exchange

**Orphan Order Handling**:
- Orders on exchange not in our tracking = orphan
- Log warning, optionally cancel (configurable)

### 6. Orchestrator (`orchestrator.py`)

**Purpose**: Coordinate multiple strategies across accounts.

**Class**: `Orchestrator`

**Responsibilities**:
- Load config, create runners
- Manage WebSocket connections per account
- Route events to correct runner(s)
- Create `Run` records in database on startup
- Coordinate startup/shutdown

**Initialization Flow**:
1. Load `GridbotConfig` from YAML
2. For each account:
   - Create `BybitRestClient`
   - Create `PublicWebSocketClient` (ticker)
   - Create `PrivateWebSocketClient` (position, order, execution)
3. For each strategy:
   - Load anchor from `GridAnchorStore` if config matches
   - Create `GridEngine` with anchor
   - Create linked `Position` pair
   - Create `StrategyRunner`
   - Create `Run` record in database
4. Wire event handlers

**Event Routing**:
```
PublicWS.ticker_stream(symbol) → runners matching symbol
PrivateWS.position_stream() → runners matching account
PrivateWS.order_stream() → runners matching account + symbol
PrivateWS.execution_stream() → runners matching account + symbol
```

**Periodic Tasks**:
- Position check: every 63s per runner
- Anchor save: after grid changes
- Reconnection health: watchdog thread (existing in `ws_client.py`)

### 7. Main Entry Point (`main.py`)

**Purpose**: Application entry point with signal handling.

**Flow**:
```python
async def main():
    config = load_config()
    db = DatabaseFactory(DatabaseSettings(...))

    orchestrator = Orchestrator(config, db)
    await orchestrator.start()

    # Wait for shutdown signal
    await orchestrator.run_until_shutdown()

    await orchestrator.stop()
```

**Signal Handling**:
- SIGINT/SIGTERM: graceful shutdown
- Cancel pending intents, flush writers, close connections

## Database Integration

**Reuse from event_saver**:
- `TradeWriter` - public trades (if capturing)
- `ExecutionWriter` - fills
- `OrderWriter` - order state changes
- `PositionWriter` - position snapshots
- `WalletWriter` - wallet snapshots
- `TickerWriter` - ticker data (if capturing)

**New Records**:
- `Run` record created on startup per strategy
- `Run.status` updated on shutdown

**Import Pattern**:
```python
from event_saver.writers import (
    ExecutionWriter, OrderWriter, PositionWriter, WalletWriter
)
```

## Files to Create

```
apps/gridbot/
├── pyproject.toml
├── conf/
│   └── gridbot.yaml.example
├── src/gridbot/
│   ├── __init__.py
│   ├── config.py           # Pydantic config models
│   ├── executor.py         # Intent → API calls
│   ├── retry_queue.py      # Failed intent retry
│   ├── runner.py           # StrategyRunner
│   ├── reconciler.py       # Exchange state sync
│   ├── orchestrator.py     # Multi-strategy coordinator
│   └── main.py             # Entry point
└── tests/
    ├── __init__.py
    ├── conftest.py
    ├── test_config.py
    ├── test_executor.py
    ├── test_retry_queue.py
    ├── test_runner.py
    ├── test_reconciler.py
    └── test_orchestrator.py
```

## Files to Modify

### `packages/bybit_adapter/src/bybit_adapter/rest_client.py`

Add order management methods:

```python
def place_order(
    self,
    symbol: str,
    side: str,  # 'Buy' or 'Sell'
    order_type: str,  # 'Limit'
    qty: str,
    price: str,
    reduce_only: bool = False,
    order_link_id: Optional[str] = None,
) -> dict:
    """Place a new order. Returns order response dict."""

def cancel_order(self, symbol: str, order_id: str) -> bool:
    """Cancel an order by order_id. Returns True if successful."""

def get_open_orders(
    self,
    symbol: str,
    limit: int = 50,
) -> list[dict]:
    """Fetch all open orders for symbol with pagination."""
```

Reference: `bbu_reference/bbu2-master/bybit_api_usdt.py:246-269, 380-404, 442-448`

### `packages/bybit_adapter/src/bybit_adapter/__init__.py`

Export new methods (if adding new classes).

## Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                         YAML Config                          │
└─────────────────────────┬───────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                       Orchestrator                           │
│  - Creates runners, connections, DB records                  │
└───────┬─────────────────┬─────────────────┬─────────────────┘
        │                 │                 │
        ▼                 ▼                 ▼
┌───────────────┐ ┌───────────────┐ ┌───────────────┐
│ PublicWS      │ │ PrivateWS     │ │ RestClient    │
│ (ticker)      │ │ (pos/ord/exec)│ │ (orders)      │
└───────┬───────┘ └───────┬───────┘ └───────┬───────┘
        │                 │                 │
        └────────┬────────┘                 │
                 ▼                          │
┌─────────────────────────────────────────────────────────────┐
│                     StrategyRunner                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ GridEngine  │  │ Position(L) │  │ Position(S) │          │
│  └──────┬──────┘  └─────────────┘  └─────────────┘          │
│         │                                                    │
│         ▼ Intents                                            │
│  ┌─────────────┐      ┌─────────────┐                       │
│  │  Executor   │◄────►│ RetryQueue  │                       │
│  └──────┬──────┘      └─────────────┘                       │
└─────────┼───────────────────────────────────────────────────┘
          │
          ▼ (shadow: log only)
┌─────────────────────────────────────────────────────────────┐
│                      Bybit REST API                          │
└─────────────────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────┐
│                     DB Writers                               │
│  ExecutionWriter, OrderWriter, PositionWriter, WalletWriter │
└─────────────────────────────────────────────────────────────┘
```

## Key Algorithms

### Intent Execution with Deduplication

```
For each PlaceLimitIntent:
1. Check if client_order_id already in tracked_orders
   - If yes and status='placed': skip (already on exchange)
   - If yes and status='pending': skip (in flight)
2. Add to tracked_orders with status='pending'
3. Call executor.execute_place(intent)
4. On success: update status='placed', store order_id
5. On failure: add to retry_queue
```

### Position Check Cycle (every ~63s)

```
1. Reset amount multipliers to 1.0
2. Fetch positions from exchange (or use cached from WebSocket)
3. Update Position objects with new data
4. Calculate position_ratio = long_size / short_size
5. Call position.calculate_amount_multiplier() for both
6. Log position state
7. Save position snapshot to DB
```

### Startup Reconciliation

```
1. Load anchor from GridAnchorStore
2. Check if config (grid_step, grid_count) matches saved
   - If yes: use saved anchor_price
   - If no: anchor_price = None (will build fresh)
3. Create GridEngine with anchor_price
4. Fetch open orders from exchange
5. Build limit_orders dict: {'long': [...], 'short': [...]}
6. First on_event() with TickerEvent will:
   - Build grid if needed (fresh or from anchor)
   - Generate intents considering existing orders
```

## Testing Strategy

1. **Unit tests**: Each module in isolation with mocks
2. **Integration tests**: Runner + Engine + mock Executor
3. **Shadow mode validation**: Run alongside original bot, compare intent logs

## Dependencies

```toml
# apps/gridbot/pyproject.toml
[project]
dependencies = [
    "gridcore",
    "bybit-adapter",
    "grid-db",
    "event-saver",  # For writers
    "pyyaml>=6.0",
    "pydantic>=2.0",
    "pydantic-settings>=2.0",
]

[tool.uv.sources]
gridcore = { workspace = true }
bybit-adapter = { workspace = true }
grid-db = { workspace = true }
event-saver = { workspace = true }
```
