# 0011: Add Risk Calculations to Backtest

Integrate `gridcore.Position` risk multipliers into the backtest engine so simulated order sizing matches the live bot's risk-aware behavior. Currently the backtest uses `intent.qty` directly with no adjustments — risk rules (liquidation danger, margin imbalance, position ratio) are ignored, making backtest results optimistic compared to live.

---

## Existing Code to Reuse

| What | File | Notes |
|------|------|-------|
| Risk engine | `packages/gridcore/src/gridcore/position.py` | `Position`, `PositionState`, `RiskConfig`, `create_linked_pair()` |
| PnL formulas | `packages/gridcore/src/gridcore/pnl.py` | `calc_position_value()`, `calc_unrealised_pnl()`, `calc_liq_ratio()` |
| Backtest runner | `apps/backtest/src/backtest/runner.py` | `BacktestRunner` — main tick loop |
| Backtest executor | `apps/backtest/src/backtest/executor.py` | `BacktestExecutor` — has `qty_calculator` hook |
| Position tracker | `apps/backtest/src/backtest/position_tracker.py` | `BacktestPositionTracker` — PnL only, no margin/liq |
| Backtest config | `apps/backtest/src/backtest/config.py` | `BacktestStrategyConfig` already has `min_liq_ratio`, `max_liq_ratio`, `min_total_margin` fields (defined but unused) |
| Live bot pattern | `apps/gridbot/src/gridbot/runner.py:374-459` | `on_position_update()`, `get_amount_multiplier()`, `_build_position_state()` |

---

## Problem: Simulated Liquidation Price

The live bot gets `liqPrice` from Bybit's position endpoint. In backtest there is no exchange — we must **estimate** it.

Bybit's simplified liquidation formula for linear USDT perpetuals (isolated margin):
- **Long**: `liq_price = entry_price * (1 - 1/leverage + maintenance_margin_rate)`
- **Short**: `liq_price = entry_price * (1 + 1/leverage - maintenance_margin_rate)`

Where `maintenance_margin_rate` is typically 0.5% for most tiers. This is an approximation — Bybit uses tiered MMR based on position size, but for risk multiplier purposes (which only checks ratios like `liq_price / last_price`) this approximation is sufficient.

Add a new config field `leverage` (default 10) and `maintenance_margin_rate` (default 0.005) to `BacktestStrategyConfig`.

---

## Algorithm: Step-by-Step

### After each fill in `BacktestRunner._process_fill()`:

1. **Build `PositionState` for both directions** from `BacktestPositionTracker` state:
   - `size` = tracker.state.size
   - `entry_price` = tracker.state.avg_entry_price
   - `margin` = `calc_position_value(size, entry_price) / wallet_balance` (bbu2 pattern)
   - `liquidation_price` = estimated from entry_price, leverage, mmr (formula above)
   - `leverage` = from config
   - `position_value` = `calc_position_value(size, entry_price)`

2. **Reset and calculate multipliers** (same pattern as live bot `runner.py:412-429`):
   ```
   long_position.reset_amount_multiplier()
   short_position.reset_amount_multiplier()
   long_position.calculate_amount_multiplier(long_state, short_state, last_price)
   short_position.calculate_amount_multiplier(short_state, long_state, last_price)
   ```

3. **Store current multipliers** on the runner for use by the executor's `qty_calculator`.

### When placing orders in `BacktestExecutor.execute_place()`:

4. **Apply multiplier to qty** via the existing `qty_calculator` callback:
   - Determine direction and side from the intent
   - Look up multiplier: `runner.get_amount_multiplier(direction, side)`
   - Return `intent.qty * multiplier`

---

## Files to Modify

### `apps/backtest/src/backtest/config.py`
- Add `leverage: int = Field(default=10, ge=1)` to `BacktestStrategyConfig`
- Add `maintenance_margin_rate: float = Field(default=0.005, ge=0)` to `BacktestStrategyConfig`
- Add `enable_risk_multipliers: bool = Field(default=True)` to `BacktestStrategyConfig` (allows toggling for A/B comparison)

### `apps/backtest/src/backtest/runner.py`
- Import `Position`, `PositionState`, `RiskConfig`, `create_linked_pair` from gridcore
- Import `calc_position_value` from `gridcore.pnl`
- In `__init__()`:
  - Create linked `Position` pair using `RiskConfig` from strategy config (fields already exist)
  - Store `_leverage` and `_mmr` from config
- Add `_build_position_state(tracker, wallet_balance, direction)` method:
  - Builds `gridcore.PositionState` from `BacktestPositionTracker.state`
  - Estimates liquidation price from entry_price + leverage + mmr
- Add `_update_risk_multipliers(last_price)` method:
  - Resets both positions, calculates multipliers (mirrors live bot pattern)
- Call `_update_risk_multipliers()` at end of `_process_fill()`
- Add `get_amount_multiplier(direction, side) -> float` method
- Wire up `qty_calculator` callback to executor that uses multipliers

### `apps/backtest/tests/test_runner.py`
- Test risk multiplier calculation after fills
- Test that `qty_calculator` applies multiplier to order qty
- Test `enable_risk_multipliers=False` bypasses multiplier (multipliers stay 1.0)
- Test high liq risk scenario produces expected multiplier adjustments

---

## Design Decisions

1. **Estimated liq price vs exact**: Use simplified formula. The risk multiplier only cares about the ratio `liq_price / last_price`, and the approximation is close enough for simulation purposes.

2. **`enable_risk_multipliers` toggle**: Allows running the same backtest with and without risk to measure the impact of risk management on PnL.

3. **Reuse `qty_calculator` hook**: The `BacktestExecutor` already has a `qty_calculator: Optional[Callable]` parameter — no changes to executor needed. The runner passes a callback at construction time.

4. **Recalculate after every fill**: Matches live bot's `on_position_update()` which fires after every position change. In backtest this is after every fill.
