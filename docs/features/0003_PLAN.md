# Phase D: Data Capture

## Overview

Implement a data capture system that streams public market data (tickers, trades) and private account data (executions, orders, positions, wallet) from Bybit WebSockets to the database. Includes REST API reconciliation for gap detection on WebSocket reconnection.

**Requirements:**
- Configurable symbol list (any symbols from config)
- All private streams (executions, orders, positions, wallet)
- Basic REST reconciliation for gap detection

---

## 1. Package Structure

### 1.1 New Package: `packages/bybit_adapter/`

```
packages/bybit_adapter/
├── pyproject.toml
└── src/bybit_adapter/
    ├── __init__.py
    ├── normalizer.py       # WS message → gridcore Event
    ├── ws_client.py        # WebSocket connection management
    ├── rest_client.py      # REST API for gap filling
    └── rate_limiter.py     # Per-account rate limit tracking
```

**Dependencies:** `pybit>=5.8`, `gridcore`

### 1.2 New Application: `apps/event_saver/`

```
apps/event_saver/
├── pyproject.toml
└── src/event_saver/
    ├── __init__.py
    ├── config.py                 # Pydantic settings
    ├── collectors/
    │   ├── __init__.py
    │   ├── public_collector.py   # ticker + publicTrade streams
    │   └── private_collector.py  # execution, order, position, wallet streams
    ├── writers/
    │   ├── __init__.py
    │   ├── trade_writer.py       # Bulk insert for public trades
    │   └── execution_writer.py   # Private execution persistence
    ├── reconciler.py             # REST gap detection + filling
    └── main.py                   # Entry point
```

**Dependencies:** `bybit-adapter`, `grid-db`, `pydantic-settings>=2.0`

### 1.3 Modifications to `shared/db/src/grid_db/`

**models.py** - Add:
- `PositionSnapshot` - Position state from WebSocket
- `WalletSnapshot` - Wallet balance from WebSocket

**repositories.py** - Add:
- `PublicTradeRepository` - Bulk insert, time-range queries
- `PrivateExecutionRepository` - Run-scoped queries, deduplication

---

## 2. Module Specifications

### 2.1 normalizer.py

```python
class BybitNormalizer:
    """Converts Bybit WebSocket messages to gridcore Event objects."""

    def __init__(self, user_id=None, account_id=None, run_id=None):
        # Multi-tenant tags for private events

    def normalize_ticker(self, message: dict) -> TickerEvent
    def normalize_public_trade(self, message: dict) -> list[PublicTradeEvent]
    def normalize_execution(self, message: dict) -> list[ExecutionEvent]
    def normalize_order(self, message: dict) -> list[OrderUpdateEvent]
```

**Event Mapping - publicTrade.{symbol}:**

| Bybit Field | gridcore Field | Transformation |
|-------------|----------------|----------------|
| `data[].i` | `trade_id` | str |
| `data[].T` | `exchange_ts` | ms → datetime(UTC) |
| `data[].S` | `side` | "Buy" / "Sell" |
| `data[].p` | `price` | str → Decimal |
| `data[].v` | `size` | str → Decimal |
| (local) | `local_ts` | datetime.now(UTC) |

**Event Mapping - execution:**

| Bybit Field | gridcore Field | Transformation |
|-------------|----------------|----------------|
| `data[].execId` | `exec_id` | str |
| `data[].orderId` | `order_id` | str |
| `data[].orderLinkId` | `order_link_id` | str |
| `data[].execTime` | `exchange_ts` | ms → datetime(UTC) |
| `data[].side` | `side` | "Buy" / "Sell" |
| `data[].execPrice` | `price` | str → Decimal |
| `data[].execQty` | `qty` | str → Decimal |
| `data[].execFee` | `fee` | str → Decimal |
| `data[].closedPnl` | `closed_pnl` | str → Decimal |

**Filter:** `category == "linear"` AND `execType == "Trade"`

### 2.2 ws_client.py

```python
@dataclass
class ConnectionState:
    connected_at: Optional[datetime]
    disconnected_at: Optional[datetime]
    last_message_ts: Optional[datetime]
    reconnect_count: int

class PublicWebSocketClient:
    """Multi-symbol public streams."""

    def __init__(self, symbols: list[str], testnet: bool,
                 on_ticker, on_trade, on_disconnect, on_reconnect):
        # Uses pybit.unified_trading.WebSocket

    async def connect(self) -> None
    async def disconnect(self) -> None
    def get_connection_state(self) -> ConnectionState

class PrivateWebSocketClient:
    """Per-account private streams."""

    def __init__(self, api_key: str, api_secret: str, testnet: bool,
                 on_execution, on_order, on_position, on_wallet,
                 on_disconnect, on_reconnect):
        # Authenticated connection
```

**pybit subscription methods:**
- `ws.ticker_stream(symbol, callback)`
- `ws.trade_stream(symbol, callback)` - publicTrade
- `ws.execution_stream(callback)`
- `ws.order_stream(callback)`
- `ws.position_stream(callback)`
- `ws.wallet_stream(callback)`

### 2.3 rate_limiter.py

```python
class RateLimiter:
    """Per-account rate limit tracking."""

    def __init__(self, order_rate=10, query_rate=20, window_seconds=1.0)

    def can_request(self, request_type: "order" | "query") -> bool
    def record_request(self, request_type) -> None
    def wait_time(self, request_type) -> float
    def record_rate_limit_hit(self) -> None  # Triggers exponential backoff
```

### 2.4 rest_client.py

```python
class BybitRestClient:
    """REST API client for reconciliation."""

    def __init__(self, api_key: str, api_secret: str, testnet: bool)

    async def get_recent_trades(self, symbol: str, limit: int = 1000) -> list[dict]
    async def get_executions(self, start_time: int, end_time: int, limit: int = 100) -> list[dict]
    async def get_order_history(self, start_time: int, end_time: int) -> list[dict]
    async def get_positions(self) -> list[dict]
    async def get_wallet_balance(self) -> dict
```

### 2.5 config.py

```python
class EventSaverConfig(BaseSettings):
    symbols: list[str] = ["BTCUSDT", "ETHUSDT"]
    testnet: bool = True
    batch_size: int = 100
    flush_interval: float = 5.0
    gap_threshold_seconds: float = 5.0
    reconnect_delay: float = 1.0
    max_reconnect_delay: float = 60.0

    model_config = SettingsConfigDict(env_prefix="EVENTSAVER_")
```

**Environment Variables:**
- `EVENTSAVER_SYMBOLS` - Comma-separated: `"BTCUSDT,ETHUSDT"`
- `EVENTSAVER_TESTNET` - `true` / `false`
- `EVENTSAVER_BATCH_SIZE` - Integer
- `EVENTSAVER_FLUSH_INTERVAL` - Float seconds
- `EVENTSAVER_GAP_THRESHOLD` - Float seconds

### 2.6 public_collector.py

```python
class PublicCollector:
    """Collects public data for configured symbols."""

    def __init__(self, symbols: list[str], on_ticker, on_trades,
                 on_gap_detected, testnet: bool)

    async def start(self) -> None
    async def stop(self) -> None

    # Internal handlers
    def _handle_ticker(self, message: dict) -> None
    def _handle_trade(self, message: dict) -> None
    def _handle_reconnect(self, disconnected_at, reconnected_at) -> None
```

### 2.7 private_collector.py

```python
@dataclass
class AccountContext:
    account_id: UUID
    user_id: UUID
    run_id: Optional[UUID]
    api_key: str
    api_secret: str
    environment: str
    symbols: list[str]

class PrivateCollector:
    """Collects private data for a single account."""

    def __init__(self, context: AccountContext, on_execution, on_order,
                 on_position, on_wallet, on_gap_detected)

    async def start(self) -> None
    async def stop(self) -> None
```

### 2.8 trade_writer.py

```python
class TradeWriter:
    """Buffers and bulk-inserts public trades."""

    def __init__(self, db: DatabaseFactory, batch_size: int, flush_interval: float)

    async def write(self, events: list[PublicTradeEvent]) -> None
    async def flush(self) -> None
    async def start_auto_flush(self) -> None
    async def stop(self) -> None
```

**Bulk Insert Algorithm:**
1. Buffer events in deque
2. On `len(buffer) >= batch_size`: flush
3. On `time_since_last_flush >= flush_interval`: flush
4. Flush converts events to ORM models, calls `session.bulk_save_objects()`

### 2.9 reconciler.py

```python
class GapReconciler:
    """REST API reconciliation for gap detection."""

    def __init__(self, db: DatabaseFactory, rest_client: BybitRestClient,
                 gap_threshold_seconds: float)

    async def reconcile_public_trades(self, symbol: str,
                                       gap_start: datetime, gap_end: datetime) -> int
    async def reconcile_executions(self, account_id: UUID,
                                    gap_start: datetime, gap_end: datetime) -> int
```

**Gap Detection Algorithm:**
1. On WebSocket disconnect: record `disconnect_ts`
2. On WebSocket reconnect: calculate `gap = reconnect_ts - disconnect_ts`
3. If `gap > threshold`: trigger reconciliation
4. Query DB for `last_persisted_ts`
5. Call REST API for data in `[last_persisted_ts, reconnect_ts]`
6. Deduplicate by `trade_id` or `exec_id`
7. Bulk insert missing records

---

## 3. Database Schema Extensions

### 3.1 PositionSnapshot Model

```python
class PositionSnapshot(Base):
    __tablename__ = "position_snapshots"

    id: BigInteger (PK, autoincrement)
    account_id: String(36), NOT NULL
    symbol: String(20), NOT NULL
    exchange_ts: DateTime(tz), NOT NULL
    local_ts: DateTime(tz), NOT NULL
    side: String(4), NOT NULL  # "Buy" or "Sell"
    size: Numeric(20,8), NOT NULL
    entry_price: Numeric(20,8), NOT NULL
    liq_price: Numeric(20,8), nullable
    unrealised_pnl: Numeric(20,8), nullable
    raw_json: JSON, nullable

    Index: (account_id, exchange_ts)
```

### 3.2 WalletSnapshot Model

```python
class WalletSnapshot(Base):
    __tablename__ = "wallet_snapshots"

    id: BigInteger (PK, autoincrement)
    account_id: String(36), NOT NULL
    exchange_ts: DateTime(tz), NOT NULL
    local_ts: DateTime(tz), NOT NULL
    coin: String(20), NOT NULL  # "USDT"
    wallet_balance: Numeric(20,8), NOT NULL
    available_balance: Numeric(20,8), NOT NULL
    raw_json: JSON, nullable

    Index: (account_id, exchange_ts)
```

### 3.3 PublicTradeRepository

```python
class PublicTradeRepository(BaseRepository[PublicTrade]):
    def get_by_symbol_range(self, symbol, start_ts, end_ts, limit) -> list[PublicTrade]
    def get_last_trade_ts(self, symbol) -> Optional[datetime]
    def bulk_insert(self, trades: list[PublicTrade]) -> int
```

### 3.4 PrivateExecutionRepository

```python
class PrivateExecutionRepository(BaseRepository[PrivateExecution]):
    def get_by_run_range(self, run_id, start_ts, end_ts) -> list[PrivateExecution]
    def get_last_execution_ts(self, account_id) -> Optional[datetime]
    def exists_by_exec_id(self, exec_id) -> bool
```

---

## 4. main.py Orchestrator

```python
async def main():
    # 1. Load configuration
    config = EventSaverConfig()
    db = DatabaseFactory(DatabaseSettings())

    # 2. Start public collector
    public_collector = PublicCollector(
        symbols=config.symbols,
        on_trades=trade_writer.write,
        on_gap_detected=reconciler.reconcile_public_trades,
    )

    # 3. Load accounts from database
    with db.get_session() as session:
        accounts = load_enabled_accounts(session)

    # 4. Start private collectors (one per account)
    private_collectors = []
    for account in accounts:
        collector = PrivateCollector(
            context=AccountContext(...),
            on_execution=execution_writer.write,
            on_gap_detected=reconciler.reconcile_executions,
        )
        private_collectors.append(collector)

    # 5. Run until shutdown
    await asyncio.gather(
        public_collector.start(),
        *[c.start() for c in private_collectors],
    )
```

---

## 5. Testing Strategy

### Unit Tests (≥80% coverage)

| Module | Test Focus |
|--------|------------|
| normalizer.py | All event type conversions, edge cases |
| rate_limiter.py | Sliding window, backoff |
| ws_client.py | Connection state tracking (mock pybit) |
| trade_writer.py | Batching, flushing logic |
| reconciler.py | Gap calculation, deduplication |

### Integration Tests

- End-to-end: WebSocket → Normalize → Buffer → DB
- Gap detection: Simulate disconnect, verify reconciliation
- Multi-account: Verify data isolation per account
- Performance: 1000 trades bulk insert < 1 second

---

## 6. Files Summary

| New File | Purpose |
|----------|---------|
| `packages/bybit_adapter/pyproject.toml` | Package config |
| `packages/bybit_adapter/src/bybit_adapter/__init__.py` | Exports |
| `packages/bybit_adapter/src/bybit_adapter/normalizer.py` | Event normalization |
| `packages/bybit_adapter/src/bybit_adapter/ws_client.py` | WebSocket clients |
| `packages/bybit_adapter/src/bybit_adapter/rest_client.py` | REST API |
| `packages/bybit_adapter/src/bybit_adapter/rate_limiter.py` | Rate limiting |
| `apps/event_saver/pyproject.toml` | App config |
| `apps/event_saver/src/event_saver/__init__.py` | Exports |
| `apps/event_saver/src/event_saver/config.py` | Settings |
| `apps/event_saver/src/event_saver/collectors/public_collector.py` | Public streams |
| `apps/event_saver/src/event_saver/collectors/private_collector.py` | Private streams |
| `apps/event_saver/src/event_saver/writers/trade_writer.py` | Trade persistence |
| `apps/event_saver/src/event_saver/writers/execution_writer.py` | Execution persistence |
| `apps/event_saver/src/event_saver/reconciler.py` | Gap filling |
| `apps/event_saver/src/event_saver/main.py` | Entry point |

| Modified File | Change |
|---------------|--------|
| `shared/db/src/grid_db/models.py` | Add PositionSnapshot, WalletSnapshot |
| `shared/db/src/grid_db/repositories.py` | Add PublicTradeRepository, PrivateExecutionRepository |
| `shared/db/src/grid_db/__init__.py` | Export new classes |
| `pyproject.toml` (root) | Add packages/bybit_adapter, apps/event_saver to workspace |
| `RULES.md` | Add Phase D implementation notes |

---

## 7. Done Criteria

1. Configurable symbols loaded from environment
2. Public trades persisted with exchange_ts, local_ts, trade_id, price, size, side
3. Private executions tagged with run_id, account_id, user_id
4. All private streams captured (executions, orders, positions, wallet)
5. Bulk insert performance: 1000 trades < 1 second
6. Gap > 5 seconds triggers REST reconciliation
7. Multi-account data isolation verified
8. Test coverage ≥ 80% for new code
9. No breaking changes to gridcore or grid_db
10. Manual verification: start event_saver, observe data in database
