# 0010: PnL Checker — Live Position Validation Tool

Standalone CLI tool (`apps/pnl_checker/`) that connects to a live Bybit mainnet account (Unified Trading Account, hedge mode), fetches all open positions for configured symbols, and validates the codebase's PnL/risk calculations against Bybit's reported values. **Read-only**: no orders placed, no bot execution.

---

## Existing Code to Reuse

| What | File | Notes |
|------|------|-------|
| REST client | `packages/bybit_adapter/src/bybit_adapter/rest_client.py` | `get_positions()`, `get_wallet_balance()` already exist. Need to add `get_tickers()` and `get_transaction_log()` methods |
| PnL formulas (bbu2) | `apps/backtest/src/backtest/position_tracker.py` | `calculate_unrealized_pnl()`, `calculate_unrealized_pnl_percent()` — the bbu2 ROE formula |
| Position risk mgmt | `packages/gridcore/src/gridcore/position.py` | `Position`, `RiskConfig`, `PositionState`, `create_linked_pair()` |
| Config pattern | `apps/gridbot/src/gridbot/config.py` | YAML + Pydantic pattern to follow |
| App structure | `apps/gridbot/pyproject.toml`, `apps/gridbot/src/gridbot/main.py` | Package layout and CLI entry point pattern |

---

## New REST Client Methods Needed

Add to `BybitRestClient` in `packages/bybit_adapter/src/bybit_adapter/rest_client.py`:

### `get_tickers(symbol) -> dict`
- Calls `self._session.get_tickers(category="linear", symbol=symbol)`
- Returns single ticker dict with `lastPrice`, `markPrice`, `fundingRate`, `bid1Price`, `ask1Price`
- Needed because: `get_positions()` returns `markPrice` but not `lastPrice`; we need both for dual-price unrealized PnL

### `get_transaction_log(symbol, type, start_time, end_time, limit, cursor) -> tuple[list[dict], Optional[str]]`
- Calls `self._session.get_transaction_log(accountType="UNIFIED", category="linear", type="SETTLEMENT", ...)`
- Returns list of settlement records with `funding` field (funding fee amount per record) and pagination cursor
- Filter by symbol to get funding fees for a specific position
- Needed because: Bybit doesn't expose cumulative funding on the position endpoint; must sum from transaction log

---

## New Files to Create

```
apps/pnl_checker/
├── pyproject.toml
├── src/pnl_checker/
│   ├── __init__.py
│   ├── main.py          # CLI entry point (argparse)
│   ├── config.py         # PnlCheckerConfig (YAML + Pydantic)
│   ├── fetcher.py        # Fetch position/wallet/ticker/funding data from Bybit
│   ├── calculator.py     # Our PnL + risk calculations
│   ├── comparator.py     # Compare our values vs Bybit's, compute deltas
│   └── reporter.py       # Console table (rich) + JSON file output
└── tests/
    ├── __init__.py
    ├── test_calculator.py
    ├── test_comparator.py
    └── test_reporter.py
```

---

## Config File: `apps/pnl_checker/conf/pnl_checker.yaml`

```yaml
account:
  api_key: "xxx"
  api_secret: "yyy"

symbols:
  - symbol: "BTCUSDT"
    tick_size: "0.1"
  - symbol: "ETHUSDT"
    tick_size: "0.01"

risk_params:
  min_liq_ratio: 0.8
  max_liq_ratio: 1.2
  max_margin: 8.0
  min_total_margin: 0.15

tolerance: 0.01  # Default USDT tolerance for pass/fail (configurable via CLI --tolerance)
```

Pydantic models:
- `SymbolConfig`: `symbol: str`, `tick_size: Decimal`
- `AccountConfig`: `api_key: str`, `api_secret: str`
- `RiskParamsConfig`: mirrors `RiskConfig` fields
- `PnlCheckerConfig`: top-level with `account`, `symbols[]`, `risk_params`, `tolerance`

---

## Algorithm: Step-by-Step

### 1. Fetch data from Bybit (`fetcher.py`)

For the configured account, call these REST endpoints:

1. **`get_positions(symbol)`** for each configured symbol → returns list of position dicts (one per positionIdx in hedge mode: `positionIdx=1` for long, `positionIdx=2` for short)
   - Key fields: `side`, `size`, `avgPrice`, `markPrice`, `liqPrice`, `leverage`, `positionIM`, `positionMM`, `unrealisedPnl`, `curRealisedPnl`, `cumRealisedPnl`, `positionValue`
   - Skip positions where `size == "0"` (no open position for that side)

2. **`get_tickers(symbol)`** for each symbol → get `lastPrice` and `markPrice`

3. **`get_wallet_balance("UNIFIED")`** → account-level summary
   - Key fields: `totalEquity`, `totalWalletBalance`, `totalMarginBalance`, `totalAvailableBalance`, `totalPerpUPL`, `totalInitialMargin`, `totalMaintenanceMargin`
   - Coin-level (USDT): `walletBalance`, `unrealisedPnl`, `cumRealisedPnl`

4. **`get_transaction_log(symbol, type="SETTLEMENT")`** for each symbol → sum `funding` field across all records to get cumulative funding fees paid/received

Return a structured `FetchResult` dataclass containing all raw data.

### 2. Calculate our values (`calculator.py`)

For each open position (long and short separately per symbol):

**Unrealized PnL (absolute)**:
- Using mark price: `(mark_price - avg_entry) * size` (long) / `(avg_entry - mark_price) * size` (short)
- Using last price: `(last_price - avg_entry) * size` (long) / `(avg_entry - last_price) * size` (short)

**Unrealized PnL % — bbu2 formula**:
- Long: `(1/entry - 1/price) * entry * 100 * leverage`
- Short: `(1/price - 1/entry) * entry * 100 * leverage`
- Calculate using both mark_price and last_price

**Unrealized PnL % — Bybit standard formula**:
- `unrealized_pnl / initial_margin * 100`
- Where `initial_margin = positionIM` from Bybit response

**Liquidation ratio** (for risk validation):
- `liq_price / last_close` (from `Position._get_liquidation_ratio()`)

**Position risk multipliers** (from `gridcore.Position`):
- Create linked pair via `Position.create_linked_pair(risk_config)`
- Build `PositionState` for each direction from Bybit position data
- Call `calculate_amount_multiplier()` for long, then short
- Output: which risk rule triggered, resulting Buy/Sell multipliers

**Funding (informational only — not compared numerically)**:
- Cumulative funding: sum of `funding` field from transaction log (historical total)
- Funding snapshot: `size * mark_price * funding_rate` (current-moment estimate per 8h cycle)
- These two values are fundamentally different (historical total vs. instantaneous rate) and cannot be meaningfully compared with a delta/tolerance check

Return a structured `CalculationResult` dataclass.

### 3. Compare (`comparator.py`)

For each field, compute:
- `bybit_value`: what Bybit API returned
- `our_value`: what our formulas calculated
- `delta`: `abs(our_value - bybit_value)`
- `pass`: `delta <= tolerance`

Per-position comparison fields:

| Field | Bybit Source | Our Calculation |
|-------|-------------|-----------------|
| Unrealized PnL | `unrealisedPnl` | `(price - entry) * size` at mark_price |
| Unrealized PnL (last price) | — (not reported) | `(price - entry) * size` at last_price |
| Unrealized PnL % (bbu2) | — | bbu2 formula |
| Unrealized PnL % (Bybit) | `unrealisedPnl / positionIM * 100` | same formula using our unrealized |
| Realized PnL | `curRealisedPnl` | — (no trades to track, display only) |
| Cumulative Realized PnL | `cumRealisedPnl` | — (display only) |
| Cumulative Funding | sum of transaction log | — (display only, historical total) |
| Funding Snapshot | — | `size * mark * rate` (display only, current-moment estimate) |
| Leverage | `leverage` | — (display only) |
| Position Value | `positionValue` | `size * mark_price` |
| Initial Margin | `positionIM` | `position_value / leverage` |
| Maintenance Margin | `positionMM` | — (display only, Bybit formula is complex) |
| Liquidation Price | `liqPrice` | — (display only, Bybit formula depends on MM tier) |
| Liq Ratio | derived | `liq_price / last_price` |
| Risk Multipliers | — | from `Position.calculate_amount_multiplier()` |

Account-level comparison:

| Field | Bybit Source |
|-------|-------------|
| Total Equity | `totalEquity` |
| Total Wallet Balance | `totalWalletBalance` |
| Total Unrealized PnL | `totalPerpUPL` |
| Total Initial Margin | `totalInitialMargin` |
| Total Maintenance Margin | `totalMaintenanceMargin` |
| Available Balance | `totalAvailableBalance` |

Return `ComparisonResult` with list of per-field comparisons and overall pass/fail.

### 4. Report (`reporter.py`)

**Console output** (using `rich` library):
- Per-position table: symbol, direction, each comparison field as a row with columns `[Field | Bybit | Ours | Delta | Status]`
- Status column: green checkmark if delta ≤ tolerance, red X if over
- Risk assessment section: show which risk rules triggered and resulting multipliers
- Account summary table: total equity, margin, PnL
- Final verdict: overall PASS/FAIL count

**JSON output** (to `output/pnl_check_<timestamp>.json`):
- Full structured data: timestamp, config used, per-position comparisons, account summary, pass/fail counts
- Create `output/` directory if not exists

---

## Workspace Integration

### `apps/pnl_checker/pyproject.toml`
```toml
[project]
name = "pnl-checker"
version = "0.1.0"
dependencies = [
    "gridcore",
    "bybit-adapter",
    "pyyaml>=6.0",
    "pydantic>=2.0",
    "rich>=13.0",
]
```

### Root `pyproject.toml` updates
- Add `"apps/pnl_checker/src"` to `pythonpath` in pytest config
- Add `"apps/pnl_checker/tests"` to `testpaths`

### Root `Makefile` update
- Add `pnl_checker` to the `make test` target list

---

## CLI Interface

```
python -m pnl_checker.main --config apps/pnl_checker/conf/pnl_checker.yaml [--tolerance 0.01] [--output output/] [--debug]
```

- `--config` / `-c`: path to YAML config (required, or use `PNL_CHECKER_CONFIG_PATH` env var)
- `--tolerance` / `-t`: override tolerance from config (in USDT)
- `--output` / `-o`: output directory for JSON (default: `output/`)
- `--debug`: enable DEBUG logging
